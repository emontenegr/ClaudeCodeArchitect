= User API Service Specification

// Define reusable attributes
:api-p99-latency: 100ms
:api-p50-latency: 20ms
:max-requests-per-min: 100
:db-connection-pool: 25
:cache-ttl: 300s

== Context

=== Identity

*Name:* User API Service

*Paradigm:* RESTful API with JWT authentication

=== Abstract

REST API service providing user registration, authentication, and profile management for web applications.

=== Approach

Stateless authentication using JWT tokens. Users authenticate once, receive token, present token on subsequent requests. Session state cached in Redis for performance.

=== Scope

*In:* User CRUD operations, JWT authentication, session management

*Out:* OAuth/social login, multi-factor authentication, role-based authorization (separate services)

=== Stack

*Language:* Go 1.21

*Foundation:* PostgreSQL 16 for persistence, Redis 7 for session cache

*Dependencies:*

* PostgreSQL 16 (Docker: postgres:16-alpine)
* Redis 7 (Docker: redis:7-alpine)
* github.com/golang-jwt/jwt/v5@v5.2.0
* github.com/gorilla/mux@v1.8.1
* github.com/lib/pq@v1.10.9

== Core Types

=== User

[source,go]
----
type User struct {
    ID           string    // UUID v4
    Username     string    // 3-32 alphanumeric characters
    Email        string    // RFC 5322 format, unique
    PasswordHash string    // bcrypt hash, cost=12
    CreatedAt    time.Time // UTC timestamp
    UpdatedAt    time.Time // UTC timestamp
}
----

*Invariants:*

* `ID` must be valid UUID v4
* `Username` must match regex: `^[a-zA-Z0-9]{3,32}$`
* `Email` must be unique across all users
* `PasswordHash` must be bcrypt with cost factor 12

=== Session

[source,go]
----
type Session struct {
    Token     string    // JWT token
    UserID    string    // Reference to User.ID
    ExpiresAt time.Time // Token expiration (24 hours)
}
----

== Database Schema

=== Users Table

[source,sql]
----
CREATE TABLE users (
    id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username      VARCHAR(32) NOT NULL UNIQUE,
    email         VARCHAR(255) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    created_at    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
----

*Rationale:*

* UUID primary key: enables distributed ID generation
* Email index: O(log n) lookup for authentication
* Username index: O(log n) lookup for uniqueness checks

== API Specification

=== Performance Requirements

All endpoints must meet:

* P99 latency: <{api-p99-latency}
* P50 latency: <{api-p50-latency}
* Rate limit: {max-requests-per-min} requests/minute per IP
* Connection pool: {db-connection-pool} connections

=== POST /users - Create User

*Request:*

[source,http]
----
POST /users HTTP/1.1
Content-Type: application/json

{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "SecurePass123!"
}
----

*Response 201 Created:*

[source,http]
----
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "username": "john_doe",
  "email": "john@example.com",
  "createdAt": "2024-01-15T10:30:00Z"
}
----

*Response 400 Bad Request:*

[source,http]
----
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "validation_failed",
  "details": [
    {
      "field": "email",
      "message": "Invalid email format"
    }
  ]
}
----

*Response 409 Conflict:*

[source,http]
----
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": "email_already_exists",
  "message": "User with this email already exists"
}
----

*Validation Rules:*

* Username: 3-32 alphanumeric characters
* Email: Must be valid RFC 5322 format
* Password: Minimum 8 characters, at least 1 uppercase, 1 lowercase, 1 number

=== POST /login - Authenticate User

*Request:*

[source,http]
----
POST /login HTTP/1.1
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePass123!"
}
----

*Response 200 OK:*

[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresAt": "2024-01-16T10:30:00Z"
}
----

*Response 401 Unauthorized:*

[source,http]
----
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": "invalid_credentials",
  "message": "Email or password is incorrect"
}
----

*Algorithm:*

1. Lookup user by email (use idx_users_email)
2. Compare password with bcrypt.CompareHashAndPassword()
3. If match, generate JWT token (HS256, 24h expiration)
4. Store session in Redis (key: token, value: userID, TTL: {cache-ttl})
5. Return token

=== GET /users/:id - Get User

*Request:*

[source,http]
----
GET /users/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
----

*Response 200 OK:*

[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "username": "john_doe",
  "email": "john@example.com",
  "createdAt": "2024-01-15T10:30:00Z"
}
----

*Response 401 Unauthorized:*

[source,http]
----
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": "unauthorized",
  "message": "Invalid or expired token"
}
----

*Response 404 Not Found:*

[source,http]
----
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "user_not_found",
  "message": "User does not exist"
}
----

*Authentication:*

* Validate JWT token signature
* Check token expiration
* Lookup session in Redis (cache hit avoids DB query)
* If session valid, allow request

=== PUT /users/:id - Update User

*Request:*

[source,http]
----
PUT /users/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "username": "john_doe_updated",
  "email": "john.new@example.com"
}
----

*Response 200 OK:*

[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "username": "john_doe_updated",
  "email": "john.new@example.com",
  "updatedAt": "2024-01-15T11:30:00Z"
}
----

*Authorization:*

* User can only update their own record (userID from token must match :id)

=== DELETE /users/:id - Delete User

*Request:*

[source,http]
----
DELETE /users/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
----

*Response 204 No Content:*

[source,http]
----
HTTP/1.1 204 No Content
----

*Algorithm:*

1. Verify authorization (token userID matches :id)
2. Delete user from database
3. Delete all sessions for user from Redis
4. Return 204

== File Structure

[source]
----
user-api/
├── cmd/
│   └── server/
│       └── main.go              # Entry point, HTTP server setup
├── internal/
│   ├── handlers/
│   │   ├── users.go             # User CRUD handlers
│   │   └── auth.go              # Login handler
│   ├── models/
│   │   └── user.go              # User type definition
│   ├── db/
│   │   └── postgres.go          # Database connection, queries
│   ├── cache/
│   │   └── redis.go             # Redis session cache
│   └── middleware/
│       ├── auth.go              # JWT validation middleware
│       └── ratelimit.go         # Rate limiting middleware
├── go.mod
└── go.sum
----

== Deployment

*Platform:* Docker Compose for local development

*docker-compose.yml:*

[source,yaml]
----
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: userdb
      POSTGRES_USER: userapi
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  api:
    build: .
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: postgres://userapi:${DB_PASSWORD}@postgres:5432/userdb
      REDIS_URL: redis://redis:6379
      JWT_SECRET: ${JWT_SECRET}
    depends_on:
      - postgres
      - redis

volumes:
  postgres_data:
----

*Environment Variables:*

* `DATABASE_URL`: PostgreSQL connection string
* `REDIS_URL`: Redis connection string
* `JWT_SECRET`: Secret key for JWT signing (minimum 32 bytes)

== Testing Requirements

=== Coverage Targets

* Line coverage: 80% minimum
* Handler coverage: 100%
* Critical paths: 100%

=== What to Test

*Business Logic:*

* User validation (email format, username constraints, password strength)
* Password hashing (bcrypt cost=12)
* JWT token generation and validation
* Session management (creation, lookup, deletion)

*Integration Contracts:*

* Database CRUD operations
* Redis cache operations (set, get, TTL behavior)
* HTTP request/response handling

*Edge Cases:*

* Empty request bodies
* Invalid UUIDs
* Duplicate email/username
* Expired tokens
* Missing authorization headers

=== What NOT to Test

* PostgreSQL query execution (database concern)
* Redis storage reliability (cache concern)
* bcrypt hashing algorithm correctness (library concern)
* JWT library token generation (library concern)

=== Test Framework

* Framework: Go standard library testing
* Mocking: github.com/stretchr/testify@v1.8.4
* Integration: testcontainers-go for database/cache

== Performance Specifications

*Latency Requirements:*

* P99: <{api-p99-latency} (95th percentile < 50ms)
* P50: <{api-p50-latency}

*Throughput:*

* Support 1000 requests/second sustained
* Database connection pool: {db-connection-pool} connections = 1000 req/s ÷ 40 req/s per conn

*Caching Strategy:*

* Cache session lookups in Redis (TTL: {cache-ttl})
* Avoids database query for every authenticated request
* Cache hit rate target: >95%

*Rate Limiting:*

* {max-requests-per-min} requests/minute per IP
* Implementation: Token bucket algorithm
* Storage: Redis (key: IP address, value: token count)
